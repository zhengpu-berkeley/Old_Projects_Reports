
```{r}

# install.packages('pracma')
# install.packages('bazar')
library(pracma)
library(bazar)

get_initial_x_vec_and_D = function(target_density, x_domain, ...){
  
  # optimization starting point
  paramemter_init = 0
  multiples = 2
  if (x_domain[1] == -Inf && x_domain[2] == Inf){
    paramemter_init = 0
  }
  else if (x_domain[1] == -Inf){
    paramemter_init = x_domain[2] - multiples*abs(x_domain[2])
  }
  else if (x_domain[2] == Inf){
    paramemter_init = x_domain[1] + multiples*abs(x_domain[1])
  }
  else {
    paramemter_init = (x_domain[1] + x_domain[2]) / 2
  }
  
  # h(x) and -h(x)
  h_of_x = function(x){ log(target_density(x, ...)) }
  negative_h_of_x = function(x){ -h_of_x(x) }
  x_max_optim = optim(paramemter_init, negative_h_of_x, method='BFGS',
                      lower = x_domain[1], upper = x_domain[2])
  
  # get the x where log(g(x)) is maximized
  x_mid = x_max_optim$par
  lower_bound = x_mid
  upper_bound = x_mid
  
  # get the lower bound
  pdf_at_x_mid = target_density(x_mid, ...)
  threshold_density = 1e-2 * pdf_at_x_mid
  if (x_domain[1] == -Inf){
    exponent = 0
    while (target_density(lower_bound, ...) > threshold_density){
      exponent = exponent + 1
      lower_bound = x_mid - 10^exponent
    }
  } else{
    lower_bound = x_domain[1]
  }
  
  # get the upper bound
  if (x_domain[2] == Inf){
    exponent = 0
    while (target_density(upper_bound, ...) > threshold_density){
      exponent = exponent + 1
      upper_bound = x_mid + 10^exponent
    }
  } else{
    upper_bound = x_domain[2]
  }
  
  # return the x vector
  nnn = 5
  x1_to_x_mid = seq(from=lower_bound, to=x_mid, length.out=nnn)
  x_mid_to_x_2n = seq(from=x_mid, to=upper_bound, length.out=nnn)
  x_vec = c(x1_to_x_mid[2:nnn-1], x_mid+1e-3, x_mid_to_x_2n[2:nnn-1])
  D_vec = c(lower_bound, upper_bound)
  return_list = list(x_vec, D_vec, x_mid)
  
  return(return_list)
}


function_2_name = function(xk, d, target_density, ...) {
  
  # h function h(x)=log(g(x))
  h = function(x, ...){ log(target_density(x, ...)) }
  # derivative of h
  h_prime_of = function(x_vec, ...){ derivative = numdiff(h, x_vec, ...) }
  
  l = length(xk)
  z = numeric(l+1)
  z[1] = d[1]
  z[l+1] = d[2]
  
  z[2:l] = ( h(xk[2:l], ...) 
             - h(xk[1:(l-1)] , ...) 
             - xk[2:l] * h_prime_of( xk[2:l] , ...) 
             + xk[1:(l-1)] * h_prime_of( xk[1:(l-1)] , ...)) / 
    (h_prime_of( xk[1:(l-1)], ...) - h_prime_of( xk[2:l], ...))
  
  integ_first_part = exp(h(xk, ...)) / h_prime_of(xk, ...)
  integ_scnd_part = exp((z[2:(l+1)]-xk)*h_prime_of(xk, ...))  -  exp((z[1:l]-xk)*h_prime_of(xk, ...))
  integ = integ_first_part * integ_scnd_part
  
  integ_cum_sum = cumsum(integ)
  s = integ_cum_sum[l]
  I = integ_cum_sum/s

  return(list(z,I,s))
}

function_3_name = function(c, I_vec){
  sum(c > I_vec) + 1
}

get_samples_from_density = function(target_density, x_domain, n, max_iter=10*n, ...){
  
  # get h(x) = log(g(x)), and, h_prime(x)
  h_of = function(x, ...){ log(target_density(x, ...)) }
  h_prime_of = function(x_vec, ...){ derivative = numdiff(h_of, x_vec, ...) }
  
  # get initial x vector and modified appropriate domain
  x_vec_and_D_and_x_mid =  get_initial_x_vec_and_D(target_density, x_domain, ...)
  x_vec = x_vec_and_D_and_x_mid[[1]]
  D = x_vec_and_D_and_x_mid[[2]]
  x_mid = x_vec_and_D_and_x_mid[[3]]
  
  # loop over to get n samples
  samples = rep(NULL, n)
  curr_num = 0
  num_iter = 0
  while (curr_num < n && num_iter < max_iter){
    # record the number of generations
    num_iter = num_iter + 1
    
    # get z-vector and I-vector
    z_vec_and_I_vec = function_2_name(x_vec, D, target_density, ...)
    z_vec = z_vec_and_I_vec[[1]]
    I_vec = z_vec_and_I_vec[[2]]
    I_sum = z_vec_and_I_vec[[3]]
    
    c = runif(1,0,1)
    w = runif(1,0,1)
    
    # get index of where x_star would fall into
    j = function_3_name(c, I_vec)
    
    # define functions l_k_of_x and u_k_of_x
    x_j = x_vec[j]
    x_j_plus_one = x_vec[j+1]
    if (j == length(x_vec)){
      x_j_plus_one = D[2]
    }
    
    I_c = 0
    if(j != 1) {
      I_c = I_vec[j-1]
    }
    
    s1 = I_sum*(c-I_c)*h_prime_of(x_j, ...)/exp(h_of(x_j, ...)) + exp(h_prime_of(x_j, ...)*(z_vec[j]-x_vec[j]))
    
    x_star = log(s1)/h_prime_of(x_j, ...) + x_vec[j]
    
    
    l_k_of = function(x, x_j, x_j_plus_one, ...){
      numerator = (x_j_plus_one-x)*h_of(x_j, ...) + (x-x_j)*h_of(x_j_plus_one, ...)
      denominator = x_j_plus_one - x_j
      return(numerator/denominator)
    }
    u_k_of = function(x, x_j, ...){ h_of(x_j, ...) + (x-x_j)*h_prime_of(x_j, ...) }
    
    
    # acceptation criterion
    if (w <= exp(l_k_of(x_star, x_j, x_j_plus_one, ...) - u_k_of(x_star, x_j, ...))){
      curr_num = curr_num + 1
      samples[curr_num] = x_star
    } else if (w <= exp(h_of(x_star, ...) - u_k_of(x_star, x_j, ...))){
      curr_num = curr_num + 1
      samples[curr_num] = x_star
      if ((x_star - x_mid) > 1e-7){
        x_vec = sort(almost.unique(c(x_vec, x_star), tolerance=1e-7))
      }
    } else {
      if ((x_star - x_mid) > 1e-7){
        x_vec = sort(almost.unique(c(x_vec, x_star), tolerance=1e-7))
      }
    }
  }
  return(samples)
}

```




```{r}
samps = get_samples_from_density(dnorm, c(-Inf, Inf), 1000, mean=-3, sd=3.25)
hist(samps, breaks=50)
print(mean(samps))
print(sqrt(var(samps)))
```
